{
  "api/index.html": {
    "href": "api/index.html",
    "title": "Trinity RDF | Trinity 1.0",
    "keywords": "Trinity 1.0 We wanted to create a high-level RDF API for C# and Mono that makes working with RDF graph databases as simple as possible. With Trinity RDF developers can work with mapped objects and LINQ without seeing any RDF at all. ORM Benefits Shallow learning curve for developers. Best possible compatibility when integrating with existing platforms and tools. Supports enterprise application development patterns such as MVC / MVVM . Reduces potential for errors through object type constraints. Setup One of the core requirements for Trinity RDF was that ontology terms need to be easily accessible from native .NET languages. If you are using the Trinity.RDF -NuGet package you are ready to go. Ontology Constants In a pre-compilation step, our framework generates a C# representation of your ontologies in a file named obj/ontologies.g.cs . It creates classes for each ontology configured in App.config . These classes contain basic information about the ontology: // Default ontology namespace prefix (i.e. \"schema\"). string prefix = schema.Prefix; // Ontology namespace URI (i.e. \"http://schema.org\"). Uri ns = schema.Namespace; and all the RDF classes and properties defined in the ontology: // The 'Person' class with the URI \"http://schema.org/Person\" and all properties defined in the vocabulary. Class personClass = schema.Person; // String constant with the URI \"http://schema.org/Person\" string personUriString = SCHEMA.Person; These constants can then be used to create queries, add values to resources or create mappings. The convention is that lower case ontology classes (e.g. rdf) contains the Class and Property instances, upper case classes (e.g. RDF) contains the string representations neccessary for the attributes. The generation of the ontolgies can be configured in the App.config file: <configuration> ... <configSections> <section name=\"TrinitySettings\" type=\"Semiodesk.Trinity.Configuration.TrinitySettings, Semiodesk.Trinity\" /> </configSections> <!-- Generate the ontology classes in the 'CliExample'-namespace --> <TrinitySettings namespace=\"CliExample\"> <OntologySettings> <!--Generate the class 'CliExample.rdf' from the contents of the file Ontologies\\rdf.rdf --> <Ontology Uri=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\" Prefix=\"rdf\"> <FileSource Location=\"Ontologies\\rdf.rdf\" /> </Ontology> </OntologySettings> </TrinitySettings> ... </configuration> Using the namespace attribute of the TrinitySettings element you can control the CLR namespace in which the ontologies should be generated. The Uri is the namespace of the ontology. The Prefix is a short identifier for the ontology. It is used as the generated classes name. The FileSource element defines the location of the file relative to the configuration. Note: If you are using NuGet, please be aware that if you change the framework (for example from .Net 4.5 to .Net 3.5 you need to retarget the packages. In most cases the easiest way to do that is by reinstalling them. Store Connection A RDF store, Triple Store or simply just 'store' represents the physical location of the data. This can either be in a database, a remote SPARQL endpoint or just a temporary store in memory. Establish connection to a store with IStore store = StoreFactory.CreateStore(\"CONNECTIONSTRING\"); If you don't want to keep the connection store in code, you can define a connection string in the App.config <configuration> ... <connectionStrings> <add name=\"virt0\" providerName=\"Semiodesk.Trinity\" connectionString=\"provider=virtuoso;host=localhost;port=1111;uid=dba;pw=dba;rule=urn:semiodesk/ruleset\" /> </connectionStrings> ... </configuration> Then you can create a store with the followling call IStore store = StoreFactory.CreateStoreFromConfiguration(\"virt0\"); The connection string has one fixed key, the so called 'provider'. All following keys depend on the selected provider. Currently three providers are supported, OpenLink Virtuoso, SparqlEndpoints and a memory store based on dotNetRdf . It is also possible to write and load a custom store module. Loading Configurations The ontologies specified in the configuration need to be loaded into the store to do things like inferencing. The method to do this is called Store.LoadOntologySettings() . Optionally it can be given the path of a configuration file. By default it will use the App.config file of the current assembly. As second parameter you can define the base directory for the ontologies. IMPORTANT: Do not forget to set all ontologies to \"Copy always\" so they will be found at runtime. store.LoadOntologySettings(); // Or store.LoadOntologySettings(Path.Combine(Environment.CurrentDirectory, \"myConfig.cfg\")); // Or store.LoadOntologySettings(Path.Combine(Environment.CurrentDirectory, \"myConfig.cfg\"), \"C:\\\\ontologyDir\"); It is in the responsibility of the developer to decide whether the ontologies have changed and need to be redeployed. During development it usually is no issue to do that at the start of the software. OpenLink Virtuoso This store is an excellent choice as backend if you want to host your own Semantic-enabled application. You can download the open source version of it here . The following example creates a connection to an OpenLink Virtuoso: IStore store = StoreFactory.CreateStore(\"provider=virtuoso;host=localhost;port=1111;uid=dba;pw=dba\"); Possible options are: Parameter Description host Hostename of the running Virtuoso instance. port Port of the Virtuoso instance. This can be looked up in the server configuration. uid Username pw Password rule The default ruleset for inferencing. Rulesets can be defined in the App.config like this: <configuration> ... <TrinitySettings> <VirtuosoStoreSettings> <RuleSets> <RuleSet Uri=\"urn:semiodesk/ruleset\"> <Graphs> <Graph Uri=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\" /> </Graphs> </RuleSet> </RuleSets> </VirtuosoStoreSettings> </TrinitySettings> ... </configuration> Sparql Endpoints SPARQL endpoints offer a platform independent way to access linked data sets. IStore store = StoreFactory.CreateSparqlEndpointStore(new Uri(\"http://live.dbpedia.org/sparql\")); Please keep in mind that SPARQL endpoints usually do not support model management or data updates. Memory Store This store is ideal as a playground or for temporarily manipulating data. If you just want to load a serialized collection of triples or an ontology, this offers the most flexiblity. Please remember that you have to save the content manually before shutting down the application or everything is lost. IStore store = StoreFactory.CreateMemoryStore(); Custom Store If you want to use the Trinity RDF with an unsupported store, you can write a custom store provider and register it. With the following function you can try to load the custom module: StoreFactory.LoadProvider(\"CustomStoreProvider.dll\") The CustomStoreProvider.dll needs to contain a class derived from StoreProvider and an IStore implementation to work. Then you can create a connection to the store by calling the CreateStore function with the provider name you set. IStore store = StoreFactory.CreateStore(\"provider=YourProviderName\"); Model Management A model can be used to group contextual data together. They create a barrier between data that can be used to separate information and controll the access to the data. For example, it makes sense to create a model for each registered user on your system, if they are not allowed to share data. These barriers can be softend tough, as it is possible to query multiple models at once. The following code snippet outlines the basic methods for managing the models in a store: IStore store = StoreFactory.CreateStore(\"provider=virtuoso;host=localhost;port=1111;uid=dba;pw=dba\"); // We retrieve an existing or a new model. IModel model = store.GetModel(new Uri(\"http://localhost:8890/models/example\")); if(!model.IsEmpty) { model.Clear(); } // Load the contents from a file into the model. store.Read(modelUri, new Uri(\"file://example.n3\"), RdfSerializationFormat.N3); // Write the contents of a model into a file. FileStream stream = new FileStream(\"file://example.rdf\", FileMode.Create); store.Write(stream, modelUri, RdfSerializationFormat.RdfXml); Model Groups A model group allows to make queries over multiple models at once. This is great way to blend different information sources together. Due to technical restrictions it is not possible to modify the result resources tough. They are marked as read-only and a commit will result in an error. The following code piece demonstrates how model groups work: // Create model group of two models IModelGroup modelGroup = store.CreateModelGroup( new Uri(\"http://localhost/models/test1\"), new Uri(\"http://localhost/models/test2\") ); // We can use a model group like a regular model. bool contains = modelGroup.ContainsResource(new Uri(\"ex:something\")); // We can make queris on them. foreach(Contact c in modelGroup.AsQueryable<Contact>()) { Console.WriteLine(c.Name); } // Note: we cannot change resources directly! To do this we need to get // a writable represenation from the model it is stored in.. IModel test1 = store.GetModel(new Uri(\"http://localhost:8890/models/test1\")); if(test1.ContainsResource(new Uri(\"ex:thing\"))) { IResource thing = test1.GetResource(new Uri(\"ex:thing\")); thing.Name = \"Anything\"; thing.Commit(); } It is possible that a resource exist in multiple models at once, all of them with different bits of information. Therefore we have to decide which resource he want to change and thus, which part of the information we want to modify. Resource Management Creating new generic resources is done with the CreateResource function on the model: IResource john = model.CreateResource(new Uri(\"ex:john\")); Checking Properties To test if a property exists for a resource, you can call HasProperty either just with a property or with a property and value combination: // With generated ontologies john.HasProperty(schema.name); john.HasProperty(schema.name, \"John Doe\"); Iterating Properties To iterate over all properties, we can call the ListProperties method. To access the values, we have then have to call the ListValues method. There is also a GetValue method, which will only return the first value or null. foreach(Property property in john.ListProperties()) { foreach(var value in john.ListValues(property)) { Console.WriteLine($\"{john} {property} {value}\"); } } Alternatively you can call ListValues and iterate over all the triples: foreach(Tuple<Property, object> propertyValue in john.ListValues()) { Console.WriteLine($\"{john} {propertyValue.Item1} {propertyValue.Item2}\"); } Adding Properties To add a property we use the AddProperty method. Look at the Chapter Ontology Handling to see how to use properties from an ontology. // Without using generated ontologies. john.AddProperty(new Property(new Uri(\"http://schema.org/name\"), \"John Doe\"); // Using generated ontologies. john.AddProperty(rdf.type, schema.Person); john.AddProperty(schema.name, \"John Doe\"); Removing Properties To remove a property, simply call RemoveProperty with the property and the value you want to remove. // Without using generated ontologies. john.RemoveProperty(new Property(new Uri(\"http://schema.org/name\")), \"John Doe\"); // Using generated ontologies. john.RemoveProperty(schema.name, \"John Doe\"); Saving Changes To persist changes in the model, they need to be comitted. Every modification in the resource is temporary until the Commit method is called: john.Commit(); If the resource has been created by calling it's constructor and not using the IModel.CreateResource method, it can be added retroactivly by calling IModel.AddResource . The resulting copy of the resource supports the Commit method: IResource john2 = new Resource(\"ex:john2\"); john2 = model.AddResource(john); john2.Commit(); Object Mapping (ORM) Trinity RDF offers two ways for defining object mappings. The recommended way is by decorating classes and properties using attributes. The mapping is then implemented in a post-compiler step by our byte-code manipulator (cilg.exe). If for some reasons you cannot do that, you can also implement the mapping manually. In the following we describe both ways. Note: Valid types for mapping are all value types, DateTime structs and classes derived from Resource. Additionally, all collections of these types which implement the IList interface. Using Decorators // The class needs to be decorated with the RDF class it is being mapped to. [RdfClass(SCHEMA.Person)] public class Person : Agent { [RdfProperty(SCHEMA.givenName)] public string FirstName{ get; set; } [RdfProperty(SCHEMA.familyName)] public string LastName { get; set; } // It is important that the constructor with a Uri parameter is implemented. public Person(Uri uri) : base(uri) {} } For the actual mapping of properties, you just need to decorate them with the RDF property you want them to be mapped. The getter and setter need to be empty. For decoration you need to use the upper case prefix of the ontologies (e.g. SCHEMA instead of schema ) because C# only accepts string constants in this context. Manual Mapping In environments where you cannot do post-build processing, it can be desirable to use the native mapping mechanism. The following example demonstrates how this works: public class Person : Agent { // This method defines the RDF classes the type is mapped to. public override IEnumerable<Class> GetTypes() { yield return schema.Person; } // Every mapped property needs a PropertyMapping object to store the value. // It also needs the name of the property as well as the mapped RDF property as a parameter. private PropertyMapping<string> _firstNameProperty = new PropertyMapping<string>(\"FirstName\", schema.givenName); // The getters and setters access the backing field. public string FirstName { get { return GetValue(_firstNameProperty); } set { SetValue(_firstNameProperty, value); } } private PropertyMapping<string> _lastNameProperty = new PropertyMapping<string>(\"LastName\", schema.familyName); public string LastName { get { return GetValue(_lastNameProperty); } set { SetValue(_lastNameProperty, value); } } // It is important that the constructor with a Uri parameter is implemented. public Person(Uri uri) : base(uri) {} } LINQ Trinity RDF has built-in support for the Language Integrated Query (LINQ) feature of the .NET platform. This works by translating native LINQ queries into SPARQL queries at runtime. Executing Queries The AsQueryable method of the Model class is the entry point for issuing LINQ queries. The generic type argument is the type you want to start your query with. This defaults to Resource . The method accepts one boolean parameter to enable or disable inferencing with your query: using Semiodesk.Trinity; using System.Linq; public class Program { public static void Main() { IStore store = StoreFactory.CreateMemoryStore(); IModel model = store.GetModel(new Uri(\"http://localhost/models/test1\")); // Execute query without inferencing. foreach(Person person in model.AsQueryable<Person>()) { Console.WriteLine(person.Name); } // Execute query with inferencing. foreach(Agent agent in model.AsQueryable<Agent>(true)) { // Includes all the person instances listed above.. Console.WriteLine(agent.Id); } } } Paged Data Access Loading a large amount of resources takes some time. In most cases it is not necessary to access them all at once but only one at a time. For these cases the data can be loaded in chunks. The following example shows how it is done: using Semiodesk.Trinity; using System.Linq; public class Program { public static void Main() { IStore store = StoreFactory.CreateMemoryStore(); IModel model = store.GetModel(new Uri(\"http://localhost/models/test1\")); // Load 100 items per page var persons = model.AsQueryable<Person>(); // Load 10 persons per page. var pageSize = 10; // Skip one page and load the next 10 persons. foreach (Person p in persons.Skip(1 * pageSize).Take(pageSize)) { Console.WriteLine(p.Name); } } }"
  },
  "tutorials/virtuoso.html": {
    "href": "tutorials/virtuoso.html",
    "title": "Trinity RDF | OpenLink Virtuoso",
    "keywords": "OpenLink Virtuoso Many features of the Trinity RDF are geared towards the OpenLink Virtuoso database. If you create a quick installation to get you started then just follow these instructions. Windows 1. Obtaining Virtuoso You can download a pre-build OpenLink Virtuoso version here . 2. Unzip Package This is where your Virtuoso installation will reside, so pick a sensible directory. Inside this directory, you will have the following folders: Folder Description bin Contains appliation binaries. database Contains an example configuration. doc Contains documentation. hosting Additional modules. lib The libraries to access the database. vad VAD packages BPEL, Conductor, tutorials, documentation. 3. Configuring To get started quickly, you can just use the example configuration in the database folder. 4. Starting Virtuoso Here we have two options, the quickstart which creates a Virtuoso instance that stops once the console window is closed and installing Virtuoso as a Windows Service. a. Console Open a console in your Virtuoso directory and start it with the following command: bin\\virtuoso-t.exe -f -c database/virtuoso.ini Closing the console or pressing CTRL+C will stop the database server. b. Windows Service This process takes a few more steps, but the Server will automatically be started when the computer is restarted. First you need a console with administration rights. The easiest way to get one is to open the start menu, type in cmd.exe and press CTRL+SHIFT+ENTER . You then need to navigate into your Virtuoso installation directory. To install the service, enter bin\\virtuoso-t.exe +service screate -I 'My Virtuoso Server' -c database/virtuoso.ini To start the service, enter bin\\virtuoso-t.exe +service start -I 'My Virtuoso Server' If you want to delete it from your system, you can use bin\\virtuoso-t.exe +service delete -I 'My Virtuoso Server' 5. Testing Navigate to http://localhost:8890/conductor/ and try to login with the credentials dba/dba . If everything works you should now have a running Virtuoso server. 6. Using Virtuoso When you use the default configuration, you can use the following configuration string: provider=virtuoso;host=localhost;port=1111;uid=dba;pw=dba To create the store, use the following snippet: IStore store = StoreFactory.CreateStore(\"provider=virtuoso;host=localhost;port=1111;uid=dba;pw=dba\");"
  },
  "index.html": {
    "href": "index.html",
    "title": "Trinity RDF | Overview",
    "keywords": "Overview Trinity RDF is an application development platform for Microsoft .NET and Mono. It allows to easily build knowledge graph applications based on the RDF Metadata Standard issued by the World Wide Web Consortium (W3C) . Benefits Because Trinity RDF is based on open standard technology your data will be vendor-independent and easily exchangable in many years to come. Compared to many propriety graph databases, it has some considerable advantages: Standardized Graph Data Model The World Wide Web Consortium is an independent organization which standardizes internet technology such as HTML, CSS, SVG and many more. RDF technology has been continously developed and supported since 2001 and will be receiving support in the long term future. This means your data will be accessible and exchangable in decades. SPARQL Query Language Trinity RDF builds on the standardized SPARQL query language for graph databases. It is by design very similar to SQL and therefore very easy to learn. In contrast to the query languages of many property graph databases such as Neo4J , SPARQL is vendor independent and supported by a variety of database systems. Ontologies In RDF, ontologies provide powerful and flexible means for describing data structures such as classes, properties and primitive data types. Because ontologies are also stored in RDF, they are independent of the data they describe and can be updated during application runtime. Logical Inferencing When compared to traditional data modelling frameworks such as UML, ontologies allow you to define inheritance relationships not only for classes but also for properties. Thea also offer more advanced features modelling features such as stating the equality of objects and transitivity of properties. Many RDF databases can make use of logical reasoning during application runtime to answer queries about facts which have not been explicitly saved. This is very powerful in data integration and business intelligence scenarios. License The Trinity RDF library and tools are all released under the terms of the MIT license. This means you can use it for all kinds of projects, including commercial ones. The source code, documentation and issue tracking can be found at our Github project page . Technical Support If you encounter problems with Trinity RDF you can use our issue tracking system . If you are interested in priority support or need some technical expertise, you can contact Semiodesk . Please ask questions at Stackoverflow using the tag 'trinity-rdf'. Community & Contributing We'd like to encourage anyone who is interested in using or contributing to Trinity RDF to join our public mailing list for discussing anything related to this project. If you want to contribute source code, please make sure that you have all the rights for publication under a MIT license and create a pull request at our Github project site."
  },
  "tutorials/firstSteps.html": {
    "href": "tutorials/firstSteps.html",
    "title": "Trinity RDF | First Steps",
    "keywords": "First Steps Download Project The tutorial on this page should give you a first impression what you can do with Trinity RDF. If you follow the steps you will have a working application that already uses many features of the Semantic Web technology stack. This example is a simple console application that creates and queries some data. In following examples we will show you how to do more complicated things. Create Project To get started we will open Visual Studio and create a new console project, lets call it 'CliExample'. Now we can start to add the dependencies using NuGet. We add the Trinity.RDF to the project. This package contains the tools that are neccessary to create the object mapping. The resulting project structure should look like this: The package creates a folder named 'Ontologies', which contains the three most basic ontologies, rdf , rdfs and owl . The App.config file has been extended to contain the Trinity RDF configuration. Now we can start to build the domain model for our application. Manage Ontologies First we need to add the foundation of our modelling to the project, the ontologies. If you have been following this tutorial and asking yourself what an ontology is, don't worry. It's basically just a collection of classes and their properties in a standardised format. In this example you don't have to write one yourself, we can just take an existing one. If you want some background information on ontologies, read this Wikipedia article . In this example we're going to use the 'Friend of a Friend' ontology, or just foaf in short. We download a XML/RDF serialised version here and copy it into the 'Ontologies' folder in the ObjectModel project. Also to avoid confusion, we rename it to foaf.rdf . Then we just need to add the file to the project in Visual Studio. Now we need to change the configuration to make the new ontology known to Trinity.RDF. To make this happen, we add the following passage to the App.config as a child of the OntologySettings element: <Ontology Uri=\"http://xmlns.com/foaf/0.1/\" Prefix=\"foaf\"> <FileSource Location=\"Ontologies\\foaf.rdf\"/> </Ontology> With this, we tell the framework where the ontology resides, which base URI it has and the namespace prefix we want to use. A namespace prefix is a shorthand for the bulky URI. As we want to leverage inferencing, we need to tell OpenLink Virtuoso to use these ontologies, so we have to modify the RuleSet in the same file. Just replace the existing VirtuosoSpecific element with the following one and you are done: <VirtuosoStoreSettings> <RuleSets> <RuleSet Uri=\"urn:semiodesk/ruleset\"> <Graphs> <Graph Uri=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\" /> <Graph Uri=\"http://www.w3.org/2000/01/rdf-schema#\" /> <Graph Uri=\"http://www.w3.org/2002/07/owl#\" /> <Graph Uri=\"http://xmlns.com/foaf/0.1/\" /> </Graphs> </RuleSet> </RuleSets> </VirtuosoStoreSettings> When you build your project now, C# represenations of the ontologies will be created in the background. Create Mappings Now we want to create our domain model. We are building a small manager for people in groups. We are using the foaf ontology as a base, so we just have to create the classes according to the specification . Note: We are currently working on a tool to automatically create a mapping from an ontology. These steps will be significantly easier in the future. As base class for our Group and Person we want to use an Agent class. So we create a new class called Agent. using System; using System.Collections.Generic; using Semiodesk.Trinity; namespace CliExample { [RdfClass(FOAF.Agent)] public class Agent : Resource { public Agent(Uri uri) : base(uri) { EMailAccounts = new List<Resource>(); } [RdfProperty(FOAF.name)] public string Name { get; set; } [RdfProperty(FOAF.mbox)] public List<Resource> EMailAccounts { get; set; } } } The class needs to be derived from Resource . The mapping can simply be done by decorating the class and the properties with the RDF classes and properties from the foaf ontology. Note: There is a distinction to be made between the generated 'foaf' class and the upper case 'FOAF' class. The upper case version provides the string representaion of the ontology elements and can be used in decorators and attributes. The lower case variant provides Class and Property instances. Now, let's create the other two classes, Group and Person . Person is derived from Agent and has a property that models the relationship between a person and other people. [RdfClass(FOAF.Person)] public class Person : Agent { public Person(Uri uri) : base(uri) { Knows = new List<Person>(); } [RdfProperty(FOAF.knows)] public List<Person> Knows { get; set; } } And the Group , which is also derived from Agent and contains a property modelling its membership property. [RdfClass(FOAF.Group)] public class Group : Agent { public Group(Uri uri) : base(uri) { Member = new List<Agent>(); } [RdfProperty(FOAF.member)] public List<Agent> Member { get; set; } } Database Connection We want to use a Virtuoso backend for this example. It is fairly simple to set up, so just follow the instructions here . Starting the database from the console should be sufficient for this case. To tell Trinity RDF how to connect to the running Virtuoso instance, we need to add the following connection string to the App.config file. <connectionStrings> <add name=\"virt0\" providerName=\"Semiodesk.Trinity\" connectionString=\"provider=virtuoso;host=localhost;port=1111;uid=dba;pw=dba;rule=urn:semiodesk/ruleset\"/> </connectionStrings> When you build your application now, the given ontologies will be deployed to the Virtuoso instance given in the connection string. To verify this, you can look at the Virtuoso Conductor in your browser. The default URL is http://localhost:8890 , and admin login is dba/dba . You should be able see the new ontology graphs when you navigate to \"Linked Data\" -> \"Graphs\". The following screenshot shows how it should look like. Building the Application Now we can start writing the application. First we need to do some initialization and then we can open a connection to the store. This can be done by using the name of the connection string. With the LoadOntologySettings() -method we tell the store to import all ontologies from the current App.config file. In the case of the Virtuoso the ruleset is also created. SemiodeskDiscovery.Discover(); IStore store = StoreFactory.CreateStoreFromConfiguration(\"virt0\"); store.LoadOntologySettings(); Then we either create or open a model. If the model exists, we clear it, so we don't add the same information again. A model in RDF contains triples and is identified by a URI. It can be used to group information of one domain together. IModel model = store.GetModel(new Uri(\"http://semiodesk.com/example/cli\"); if(!model.IsEmpty) { model.Clear(); } Then we can start to add our mapped objects to the model. First we let the model create a new resource of type Person . The empty parameter in the CreateResource() method means that we want the model to create a URI for the resource. After adding values to the resource we need to commit it to the model by calling the Commit() method. Person john = model.CreateResource<Person>(); john.EMailAccounts.Add(new Resource(\"mailto:john.doe@example.com\")); john.Name = \"John Doe\"; john.Commit(); Group group = model.CreateResource<Group>(); group.Name = \"My Group\"; group.Member.Add(john); group.Commit(); When we want to get every Agent , meaning all Group and all Person objects, we can call model.GetResources (true) . The type restricts the query to all Agent objects. With the true parameter we tell the model to infer the types from the ontologies. Because foaf:Person and foaf:Group are subclasses of foaf:Agent the query also returns the mapped objects for these classes. foreach (Agent agent in model.GetResources<Agent>(true)) { Console.WriteLine(agent.Name); }"
  },
  "tutorials/intro.html": {
    "href": "tutorials/intro.html",
    "title": "Trinity RDF | Tutorials",
    "keywords": "Tutorials First Steps Learn the basic steps to get started. Music Browser A sample desktop application that lets you browse through artists and their records. Unity 3D A small Unity 3D example to get you started. ASP.NET A basic web application with ASP.NET and SignalR."
  },
  "tutorials/installation.html": {
    "href": "tutorials/installation.html",
    "title": "Trinity RDF | Installation",
    "keywords": "Installation On this page we describe the methods to install Trinity RDF. NuGet (Recommended) The easiest way to install the library is via NuGet . You can install the base library with the following command: > PM> Install-Package Trinity.RDF GitHub package (Not recommended)## Download the latest stable package . This archive contains everything that is needed to create a knowledge graph application with Trinity RDF. Further Information For a complete introduction follow our First Steps tutorial."
  },
  "tutorials/webApp.html": {
    "href": "tutorials/webApp.html",
    "title": "Trinity RDF | Web Application",
    "keywords": "Web Application This example demonstrate how to use Semiodesk Trinity with ASP.NET MVC 5 and SignalR. The resulting application is able to generate random people and connections between them. The web page visualizes the dependencies in a graph with D3js . You can download the finished example from http://static.semiodesk.com/semiodesk.trinity/examples/0.9/WebApp.zip Because of the way NuGet works, you have to add the Semiodesk Trinity packages manually. Open the Nuget Package Manager console (\"Tools\" -> \"NuGet Package Manager\" -> \"Package Manager Console\") and install Semiodesk.Trinity.Modelling to the DataModel Project and Semiodesk.Trinity.Core to the EbApp. #! PM> Install-Package Semiodesk.Trinity.Modelling -ProjectName DataModel PM> Install-Package Semiodesk.Trinity.Core -ProjectName WebApp Also, you might need to configure the Virtuoso connection string in the Web.config file appropriately. Architecture and Object Model Overview To separate the data model from the application I have created a project that only contains the ontologies and the mapped classes. To keep things simple, I used the foaf ontology again. The mapping is nearly the same as the first steps example . As we want to serialize our objects to Json we need to change it a bit. Serializers often have limitation when it comes to possible dependency cycles. We need to handle the Knows relationship differently than before. To prevent loops we hide the Knows property from the serializer with JsonIgnore and create a new property that only exposes the URIs of the related objects. That way we can still access the objects, but only when we actively decide to do so. #!csharp [RdfProperty(FOAF.knows), JsonIgnore] public List<Person> Knows { get; set; } public IEnumerable<Uri> knows { get { return from x in Knows select x.Uri; } } To make the data available, I have implemented the repository pattern under Models/ResourceRepository.cs . This is used to create an additional abstraction layer between the database and it's peculiarities and the application logic. Displaying the Data The actual data is not rendered directly to html, but queried by the Javascript code that is deployed using ASP.NET. Creating a data backend is very easy using the aforementioned repository pattern and SignalR . This has the advantage that the data can be loaded asynchronously, while the web page is already displayed. The following diagram shows the full process how the data is acquired. The result is then transformed to create a visualisation with D3. Checklist Things to consider when you build a new project with ASP.NET and Trinity: Add SemiodeskDiscovery.Discover(); to Global.asax.cs -- Application_Start() Get ResourceRepository.cs and StoreFactory.cs from this example, they are generic and make your life easier. While creating the mapping classes, think about serialization issues. If you have trouble with SignalR, use ``` #!javascript $.connection.hub.logging = true;"
  },
  "tutorials/simpleUnity.html": {
    "href": "tutorials/simpleUnity.html",
    "title": "Trinity RDF | Unity 3D Game",
    "keywords": "Unity 3D Game Download Project We look at how, in general, the Trinity RDF platform can be used in combination with the Unity gaming engine . Required Knowledge Basic knowledge about Unity 3D Knowledge about C# and threading (BackgroundWorker) Technical Restrictions Object Mapping should be done in a separate project .NET 3.5 only (because of Unity) Goals This is a small 'game' which lists all books of a series on the press of a button. In this example it's the 'Lord of the Rings'. It follows the links of the subsequent works. We start out with a hard coded link to the book ' The Fellowship of the Ring '. The property dbo:subsequentWork links all three books of the trilogy together. Challenges DBpedia data does not always follow ontologies. We use for this example the Lord of the Rings trilogy. If we were to exchange that for Harry Potter books, it doesn't work because the links are not there. Setup Open the Nuget Package Manager console (Tools -> NuGet Package Manager -> Package Manager Console) and type the following: PM> Install-Package Trinity.RDF Make a release build before you open the project in Unity. You can find the scene under Assets/Scenes/Simple.scene . Getting Started First you need to set up a new Unity 3D Project. Next to the Assets folder you can put a new folder for the ontology mapping project. I usually call it External. Here we create a new C# Library project (create it either in Visual Studio or XamarinStudio/Monodevelop). To make the results of this projects available our Unity projects, we need to set the build output (preferably of the release build) to ..\\..\\Assets\\Plugins\\ The Plugins directory is a special folder of Unity which treats the contained DLLs differently. DBpedia Ontology I have picked up the DBpdia ontology here . The next step is to extract it to the ontologies directory. Then we need the foaf ontology which I stored as foaf.rdf in the ontologies directory. Then we can add the following part to the OntologySettings section in the App.config <Ontology Uri=\"http://dbpedia.org/ontology/\" Prefix=\"dbo\"> <FileSource Location=\"Ontologies\\dbpedia_2015-04.nt\"/> </Ontology> <Ontology Uri=\"http://xmlns.com/foaf/0.1/\" Prefix=\"foaf\"> <FileSource Location=\"Ontologies\\foaf.rdf\" /> </Ontology> Object Mapping Now we add the C# classes for the object mappings we want. For example we want information about written works: [RdfClass(DBO.WrittenWork)] public class WrittenWork : Resource { #region Properties [RdfProperty(FOAF.name)] public string Name { get; set; } [RdfProperty(DBO.previousWork)] public List<WrittenWork> PreviousWork { get; set; } [RdfProperty(DBO.subsequentWork)] public List<WrittenWork> SubsequentWork { get; set; } [RdfProperty(DBO.author)] public Person Author { get; set; } #endregion #region Constructors public WrittenWork(Uri uri) : base(uri) {} public WrittenWork(Resource other) : base(other) {} public WrittenWork(string uriString) : base(uriString) {} #endregion } To get information about the author, we need a mapping for foaf:Person [RdfClass(FOAF.Person)] public class Person : Resource { #region Properties [RdfProperty(FOAF.name)] public string Name { get; set; } [RdfProperty(FOAF.surname)] public string Surname { get; set; } [RdfProperty(FOAF.givenname)] public string GivenName { get; set; } #endregion #region Constructors public Person(Uri uri) : base(uri) {} #endregion } For convenience we also create a 'DataStore' class which connects to the store on creation. #!csharp public class DataStore { #region Members private readonly Uri _endpoint = new Uri(\"http://live.dbpedia.org/sparql\"); private IStore _store; public IStore Store { get { return _store; } } #endregion #region Constructors public DataStore() { SemiodeskDiscovery.Discover(); _store = StoreFactory.CreateSparqlEndpointStore(_endpoint); } #endregion } Unity 3D Integration To get Trinity RDF running in Unity 3D, you first need to set the Api Compatibility Level to .NET 2.0 Subset . For this, open the Player settings in Unity3D (Edit -> Project Settings -> Player) and change the appropriate entry. When the DataModel project is now being built in Release mode, Unity should automatically pick it up and make it available for scripting. Adding Simple Interaction For this example we just need a Canvas with a Button and a Text control. Add them to your scene (GameObject -> UI -> Canvas / Button / Text). Now we add the querying mechanism by adding a script to the canvas. For this, just select the canvas and in the Inspector click Add Component -> New Script and make sure Csharp is selected. We call this script LoadData and add the following code to it. using UnityEngine; using UnityEngine.UI; using DataModel; using Semiodesk.Trinity; using System; using System.ComponentModel; using System.Collections; using System.Collections.Generic; public class LoadData : MonoBehaviour { #region Members private DataStore _store; private IModel _model; private BackgroundWorker _worker; private readonly Queue<Action> _actions = new Queue<Action>(); private WrittenWork _currentBook; private Uri _targetBook; public Text Target; #endregion #region Methods // Use this for initialization. void Start() { _targetBook = new Uri(\"http://dbpedia.org/resource/The_Fellowship_of_the_Ring\"); _store = new DataStore(); _model = _store.Model; _worker = new BackgroundWorker(); _worker.DoWork += (object sender, DoWorkEventArgs e) => ExecuteLoad(); } // Update is called once per frame. void Update() { lock (_actions) { if( _actions.Count > 0 ) { _actions.Dequeue().Invoke(); } } } public void StartLoading() { _worker.RunWorkerAsync(); } void ExecuteLoad() { if (_currentBook == null) { _currentBook = _model.GetResource<WrittenWork>(_targetBook, null); } else { var works = _currentBook.SubsequentWork; if( works.Count > 0 ) { _currentBook = works[0]; } } if (_currentBook != null) { lock(_actions) { _actions.Enqueue(new Action (() => Target.text = _currentBook.Name)); } } } void OnDestroy() { _worker.Dispose(); } #endregion } Now we just need to set the Button to call the appropriate function. Select it and set the On Click() handler like in the following image. Note: Even tough the setting of Target.text does not seem like a call to Unity method, it could be property that calls methods which are not allowed to be called from a thread. To be safe, relay as much as possible back to the UI thread. The Result You now have a small game that gives you the title of all three parts of The Lord of the Rings if you press the button repeatedly. Hurray! :-)"
  },
  "tutorials/license.html": {
    "href": "tutorials/license.html",
    "title": "Trinity RDF | License",
    "keywords": "License The Trinity RDF library and tools found in this repository are licensed under the the MIT License (MIT). Copyright (c) 2015-2019 Semiodesk GmbH Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
  },
  "tutorials/musicBrowser.html": {
    "href": "tutorials/musicBrowser.html",
    "title": "Trinity RDF | Music Browser",
    "keywords": "Music Browser Download Project This example shows you how to access the LinkedBrainz dataset with Trinity RDF. It uses Windows Forms as UI toolkit and utilises data binding. Linkedbrainz seems to be offline. Before you try this example check the SPARQL endpoint at linkedbrainz.org! Because of the way NuGet works, there is one step that needs to be completed for the example to work. Open the Nuget Package Manager console ('Tools' -> 'NuGet Package Manager' -> 'Package Manager Console') and enter the following: PM> Install-Package Trinity.RDF Data Model This example leverages the following ontologies for creating the data model: Music Ontology (mo) Friend Of A Friend Vocabulary (foaf) Dublin Core Element Set Vocabulary (dces) For the object model we have created representations of artists and their created works: Note: As you can see, there is no connection between MusicArtist and Release . In this example we have solved the latency problem by wrapping this request in a separate query. SPARQL Endpoint To query the SPARQL endpoint we need to create a store with the appropriate parameters: IStore _store = StoreFactory.CreateSparqlEndpointStore(new Uri(\"http://linkedbrainz.org/sparql\")); IModel _model = _store.GetModel(new Uri(\"http://linkedbrainz.org/sparql\")); We use the SPARQL endpoint provider and configure the endpoint adress at http://linkedbrainz.org/sparql . Data Binding Though a bit rudimentary, data binding is possible in Windows Forms. We have created two ListBoxe s which are displaying the Title property of our objects. This can be done by setting the DisplayMember property of the ListBox . We create a VirtualizingResourceCollection and set it to the DataSource property of the ListBox . ResourceQuery artistEntity = new ResourceQuery(artist); // Artist is the concrete artist resource. ResourceQuery madeEntity = new ResourceQuery(mo.Release); artistEntity.Where(foaf.made, madeEntity); albumListBox.DataSource = new VirtualizingResourceCollection<Release>(Model, madeEntity); UI Responsiveness We have used the async / await pattern to keep the UI responsive during querying. As threading is not an issue when using a SPARQL endpoint there is no need to worry about connection pooling."
  }
}